

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Flags de control
local magmaSwampInProgress = false
local currentTween = nil
local isWaveTransitioning = false
local isChasingNPC = false
local concasserActive = false

-- BodyVelocity para control de movimiento
local bodyVelocity = Instance.new("BodyVelocity")
bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
bodyVelocity.Velocity = Vector3.new(0, 0, 0)
bodyVelocity.Parent = rootPart

-- Configuración de posiciones
local requiredPosition = Vector3.new(404, 19, -52)
local requiredRadius = 100
local SAFE_HEIGHT = 200
local DIRECT_CHASE_RADIUS = 165
local STAY_WITH_NPC_RADIUS = 40

local phase1 = Vector3.new(361, 78, 38)
local wavePositions = {
    [1] = phase1,
    [2] = Vector3.new(124, SAFE_HEIGHT, 21),
    [3] = Vector3.new(-243, 200, 4),
    [4] = Vector3.new(-233, 127, 52),
    [5] = Vector3.new(-1286, 140, 194),
    [6] = Vector3.new(-1286, 140, 194),
    [7] = Vector3.new(-1286, 140, 194)
}

local wave2ReturnPos = Vector3.new(123, 127, 21)  -- Posición de retorno después de wave 2

-- Se cambia el cooldown de Magma Swamp de 2 a 8.5 segundos
local lastMagmaSwampActivation = 0
local MIN_MAGMA_SWAMP_COOLDOWN = 0.5  -- Cambiado de 2 a 8.5

-- Agregar variable global para almacenar el CFrame inicial de Leo
local leoInitialCFrame = nil

-- Definir la posición final "oficial" de la Wave 5 (ajusta los valores según corresponda)
local wave5Pos = Vector3.new(-241, 129, 9)

-- Variables para guardar posiciones importantes
local cupidInitialCFrame = nil
local wave7Position = Vector3.new(-1286, 140, 194)

-- Mover esta función al inicio del script, antes de su primer uso
local function getCurrentHealth()
    if not player then 
        print("No se pudo encontrar LocalPlayer")
        return nil 
    end
    
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then
        print("No se pudo encontrar Character")
        return nil
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        print("No se pudo encontrar Humanoid")
        return nil
    end
    
    local health = humanoid.Health
    if health then
        local roundedHealth = math.floor(health)
        print("Vida actual:", roundedHealth)
        return roundedHealth
    else
        print("La vida es nil")
        return nil
    end
end

local function cancelCurrentTween()
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
end

local function tweenToTarget(targetPosition)
    if isWaveTransitioning then return end
    
    cancelCurrentTween()
    
    local speed = 100
    local distance = (targetPosition - rootPart.Position).Magnitude
    local tweenTime = distance / speed
    
    currentTween = TweenService:Create(rootPart, 
        TweenInfo.new(tweenTime, Enum.EasingStyle.Linear),
        {Position = targetPosition}
    )
    
    currentTween:Play()
    
    local completed = false
    local connection = currentTween.Completed:Connect(function()
        completed = true
    end)
    
    local startTime = tick()
    while not completed and (tick() - startTime) < (tweenTime + 2) and not isWaveTransitioning do
        task.wait(0.1)
    end
    
    connection:Disconnect()
    
    if not completed and not isWaveTransitioning then
        rootPart.Position = targetPosition
    end
end

-- Sistema de Concasser continuo (solo se activa al inicio)
local function startConcasserLoop()
    if concasserActive then return end
    concasserActive = true
    
    task.spawn(function()
        while concasserActive do
            local skillEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Skill")
            local connection = RunService.Heartbeat:Connect(function()
                local targetCFrame = rootPart.CFrame * CFrame.new(0, 100, 0)
                skillEvent:InvokeServer("Concasser", { cf = targetCFrame })
            end)
            task.wait(0.5)
            if connection then connection:Disconnect() end
        end
    end)
end

-- Función modificada para perseguir NPCs:
-- - Si hay un NPC a menos de 25 unidades, se teletransporta (una sola vez) y se continúa siguiéndolo con tween.
-- - Si el NPC está a más de 25 unidades, se hace tween directamente usando velocidad 35.
-- - Si el AC detecta y empuja hacia atrás (se observa un aumento anómalo en la distancia), se reintenta el tween utilizando velocidad 100.
local function chaseNPC(npc)
    if not npc or not npc:FindFirstChild("HumanoidRootPart") then return end

    isChasingNPC = true
    local tween = nil
    local speedNormal = 45      -- Velocidad para el tween normal
    local speedRetry  = 100   -- Velocidad para reintentar el tween en caso de AC (anti-cheat)
    local didTeleport = false -- Flag para asegurarse de que se haga TP solo una vez cuando el NPC está a ≤25
    local prevDistance = math.huge

    while npc 
          and npc:FindFirstChild("HumanoidRootPart") 
          and npc:FindFirstChild("Humanoid") 
          and npc.Humanoid.Health > 0 
          and not isWaveTransitioning do

        local npcPos = npc.HumanoidRootPart.Position
        local targetCF = CFrame.new(npcPos.X, npcPos.Y + 9, npcPos.Z)
        local currDistance = (rootPart.Position - npcPos).Magnitude

        if currDistance <= 25 then
            -- Si el NPC está a menos de 25 unidades:
            if not didTeleport then
                if tween then tween:Cancel() end
                print("TP por proximidad (distancia: "..currDistance..")")
                rootPart.CFrame = targetCF  -- Realiza un TP solo una vez
                didTeleport = true
            else
                -- Luego se sigue al NPC por tween con velocidad normal
                if tween then tween:Cancel() end
                local tweenInfo = TweenInfo.new(currDistance / speedNormal, Enum.EasingStyle.Linear)
                tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
                tween:Play()
                tween.Completed:Wait()
            end
        else
            -- Si el NPC está a más de 25 unidades, se realiza tween directo con velocidad normal
            didTeleport = false  -- Reinicia la flag para próximas aproximaciones del NPC
            if tween then tween:Cancel() end
            local tweenInfo = TweenInfo.new(currDistance / speedNormal, Enum.EasingStyle.Linear)
            tween = TweenInfo.new(currDistance / speedNormal, Enum.EasingStyle.Linear)
            tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
            tween:Play()
            tween.Completed:Wait()
        end

        -- Detección de retroceso por AC:
        -- Si la distancia actual supera la distancia previa en más de 5 unidades,
        -- significa que el AC nos ha mandado hacia atrás, por lo que se reintenta con velocidad 100.
        if currDistance > prevDistance + 5 then
            print("AC detectado (distancia aumentó de "..prevDistance.." a "..currDistance.."); reintentando con tween a velocidad "..speedRetry)
            if tween then tween:Cancel() end
            local tweenInfoRetry = TweenInfo.new(currDistance / speedRetry, Enum.EasingStyle.Linear)
            tween = TweenService:Create(rootPart, tweenInfoRetry, { CFrame = targetCF })
            tween:Play()
            tween.Completed:Wait()
        end

        prevDistance = currDistance
        task.wait(0.05)
    end

    if tween then tween:Cancel() end
    isChasingNPC = false
end

-- Función actualizada para activar Magma Swamp
-- Se utiliza el CFrame del localplayer (rootPart.CFrame) directamente
local function activateMagmaSwamp()
    local skillEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Skill")
    local result = skillEvent:InvokeServer("Magma Swamp")
    if not result then
        warn("Magma Swamp: resultado nil")
        return false
    end
    local magmaSwampRemote = result[1]
    local updateRemote = result[2]
    if not (magmaSwampRemote and updateRemote) then
        warn("Magma Swamp: magmaSwampRemote o updateRemote son nil.")
        return false
    end

    local connection
    connection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            updateRemote:FireServer(rootPart.CFrame)
        else
            if connection then connection:Disconnect() end
        end
    end)
    task.wait(10)
    if magmaSwampRemote then
        magmaSwampRemote:InvokeServer()
    end
    if connection then connection:Disconnect() end
    return true
end

local function getClosestNPC()
    local closest, closestDist = nil, math.huge
    
    for _, npc in ipairs(workspace.NPCs:GetChildren()) do
        if npc:FindFirstChild("HumanoidRootPart") and 
           npc:FindFirstChild("Humanoid") and 
           npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - rootPart.Position).Magnitude
            if dist < closestDist then
                closest = npc
                closestDist = dist
            end
        end
    end
    
    return closest, closestDist
end

-- Función actualizada para procesar NPCs (siempre se ataca al más cercano)
local function processNPCs()
    if isWaveTransitioning then return end
    
    local targetNPC, distance = getClosestNPC()
    if targetNPC then
        if not isChasingNPC then
            task.spawn(chaseNPC, targetNPC)
        end
        
        if tick() - lastMagmaSwampActivation >= 2 and not isWaveTransitioning then
            lastMagmaSwampActivation = tick()
            task.spawn(function()
                magmaSwampInProgress = true
                activateMagmaSwamp()
                magmaSwampInProgress = false
            end)
        end
    else
        magmaSwampInProgress = false
    end
end

local function areNPCsAlive()
    local found = false
    for _, npc in ipairs(workspace.NPCs:GetChildren()) do
        if npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
            found = true
            break
        end
    end
    return found
end

-- Activar Buso Haki
local function activateBuso()
    local args = {
        [1] = "Buso"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Haki"):FireServer(unpack(args))
end

-- Sistema de bloqueo continuo
task.spawn(function()
    while true do
        local args = {
            [1] = true,
            [2] = "Melee",
            [3] = true
        }
        ReplicatedStorage:WaitForChild("Events")
            :WaitForChild("Block"):InvokeServer(unpack(args))
        task.wait(0.5)
    end
end)

-- Secuencia principal mejorada
while (rootPart.Position - requiredPosition).Magnitude > requiredRadius do
    task.wait(0.1)
end

task.wait(3)

-- Primero subir a altura segura
print("Subiendo a altura segura inicial...")
rootPart.CFrame = CFrame.new(rootPart.Position.X, SAFE_HEIGHT, rootPart.Position.Z)
task.wait(1)

-- Luego tween a wave 1
print("Moviéndose a Wave 1...")
local targetCF = CFrame.new(wavePositions[1])
local tweenInfo = TweenInfo.new(
    1.5,  -- Duración fija como en instatp
    Enum.EasingStyle.Linear
)

local tween = TweenService:Create(rootPart, tweenInfo, {
    CFrame = targetCF
})

tween:Play()
tween.Completed:Wait()
task.wait(1)

-- Activar Concasser y Buso al inicio
startConcasserLoop()
activateBuso()

local currentWave = 1

-- Esperar a que aparezcan los NPCs de la primera wave
print("Esperando NPCs de Wave 1...")
while #workspace.NPCs:GetChildren() == 0 do
    task.wait(0.1)
end

print("Wave 1 iniciada")
tweenToTarget(wavePositions[1])
task.wait(1)

----------------------------------------------------------------------
-- Función para mover a la siguiente wave (usando tween con velocidad fija)
----------------------------------------------------------------------
local function moveToNextWave(nextPos)
    local attempts = 0
    local maxAttempts = 3
    local success = false
    local speed = 100  -- Velocidad fija para calcular la duración del tween

    while attempts < maxAttempts and not success do
        attempts = attempts + 1
        print("Transición a siguiente wave, intento " .. attempts)

        -- Subir a una altura segura
        rootPart.CFrame = CFrame.new(rootPart.Position.X, SAFE_HEIGHT, rootPart.Position.Z)
        task.wait(1)

        -- Tween horizontal hacia la posición destino
        local targetCF = CFrame.new(nextPos.X, SAFE_HEIGHT, nextPos.Z)
        local distance = (targetCF.Position - rootPart.Position).Magnitude
        local tweenDuration = distance / speed
        print("Distancia: " .. distance .. " | Duración del tween: " .. tweenDuration)

        local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        task.wait(1)

        -- Bajar a la posición final de la wave
        rootPart.CFrame = CFrame.new(nextPos)
        success = true
        print("Transición completada a la siguiente wave.")
    end

    return success
end

while currentWave <= 4 do
    isWaveTransitioning = false
    isChasingNPC = false
    magmaSwampInProgress = false
    cancelCurrentTween()
    
    print("Esperando NPCs de Wave " .. currentWave)
    local waitStart = tick()
    while #workspace.NPCs:GetChildren() == 0 do
        if tick() - waitStart > 5 then
            print("Reintentando detección de NPCs...")
            rootPart.CFrame = CFrame.new(wavePositions[currentWave])
            task.wait(1)
            waitStart = tick()
        end
        task.wait(0.1)
    end
    
    print("NPCs encontrados para Wave " .. currentWave .. ": " .. #workspace.NPCs:GetChildren())
    task.wait(1)
    
    -- NUEVO: Forzar movimiento inicial hacia los NPCs
    local initialNPC, initialDistance = getClosestNPC()
    if initialNPC and initialNPC:FindFirstChild("HumanoidRootPart") then
        print("Iniciando movimiento inicial hacia NPCs")
        local npcPos = initialNPC.HumanoidRootPart.Position
        rootPart.CFrame = CFrame.new(Vector3.new(npcPos.X, npcPos.Y + 8, npcPos.Z))
        task.wait(0.5)
    end
    
    -- Variables de control para estancamiento
    local lastNPCCount = #workspace.NPCs:GetChildren()
    local stuckTimer = tick()
    local stuckAttempts = 0
    local maxStuckAttempts = 3
    
    while areNPCsAlive() do
        print("Estado actual - Wave:", currentWave, 
              "NPCs vivos:", #workspace.NPCs:GetChildren(), 
              "isChasingNPC:", isChasingNPC)
        
        processNPCs()
        task.wait(0.1)
        
        if tick() - stuckTimer >= 5 then
            local currentNPCCount = #workspace.NPCs:GetChildren()
            print("Comprobando progreso - NPCs actuales:", currentNPCCount, "NPCs anteriores:", lastNPCCount)
            
            if currentNPCCount >= lastNPCCount then
                stuckAttempts = stuckAttempts + 1
                print("Detectado estancamiento #" .. stuckAttempts)
                
                isWaveTransitioning = false
                isChasingNPC = false
                magmaSwampInProgress = false
                cancelCurrentTween()
                
                -- Forzar movimiento hacia el NPC más cercano
                local stuckNPC, stuckDistance = getClosestNPC()
                if stuckNPC and stuckNPC:FindFirstChild("HumanoidRootPart") then
                    print("Reposicionando hacia NPC más cercano")
                    local npcPos = stuckNPC.HumanoidRootPart.Position
                    rootPart.CFrame = CFrame.new(npcPos.X, npcPos.Y + 8, npcPos.Z)
                    task.wait(0.5)
                end

                -- Si estamos en Wave 5 y estamos en la posición correcta (distancia 0),
                -- y se han alcanzado los intentos máximos, forzamos la eliminación de los NPCs.
                if currentWave == 5 then
                    local currentDistance = (rootPart.Position - wave5Pos).Magnitude
                    print("Posición Wave 5 detectada. Distancia:", currentDistance, "StuckAttempts:", stuckAttempts)
                    
                    -- Si estamos en la posición correcta, forzamos el ataque a los NPCs
                    if currentDistance < 1 then
                        print("En posición correcta para Wave 5, forzando ataque a NPCs...")
                        
                        -- Forzar el ataque a todos los NPCs
                        for _, npc in ipairs(workspace.NPCs:GetChildren()) do
                            if npc and npc:FindFirstChild("HumanoidRootPart") then
                                -- Forzar persecución y ataque al NPC
                                isChasingNPC = true
                                local npcPos = npc.HumanoidRootPart.Position
                                
                                -- Moverse cerca del NPC
                                rootPart.CFrame = CFrame.new(npcPos.X, npcPos.Y + 8, npcPos.Z)
                                task.wait(0.1)
                                
                                -- Activar MagmaSwamp
                                if not magmaSwampInProgress then
                                    activateMagmaSwamp()
                                end
                                
                                -- Forzar el ataque
                                task.spawn(function()
                                    chaseNPC(npc)
                                end)
                                
                                task.wait(0.5)  -- Esperar un poco entre cada NPC
                            end
                        end
                        
                        -- Reiniciar los contadores de estancamiento
                        stuckAttempts = 0
                        lastNPCCount = #workspace.NPCs:GetChildren()
                        stuckTimer = tick()
                    end
                end

                if stuckAttempts >= maxStuckAttempts then
                    print("Máximo número de intentos alcanzado, reiniciando wave...")
                    break
                end
            end
            
            lastNPCCount = currentNPCCount
            stuckTimer = tick()
        end
    end
    
    if stuckAttempts >= maxStuckAttempts then
        print("Reiniciando Wave " .. currentWave)
        continue
    end
    
    print("Wave " .. currentWave .. " completada")
    task.wait(1)
    
    -- Solo para wave 2, secuencia especial después de completarla
    if currentWave == 2 then
        print("Wave 2 completada, iniciando secuencia especial para wave 3...")
        isWaveTransitioning = true
        cancelCurrentTween()
        
        local speed = 55  -- Velocidad base reducida para tweens (más lento)
        
        -- Esperar 2 segundos
        task.wait(2)
        
        -- Subir directo a altura 60 (teleport)
        print("Subiendo a altura 60...")
        rootPart.CFrame = CFrame.new(rootPart.Position.X, 60, rootPart.Position.Z)
        
        
        -- TWEEN a la posición 58, 52, 22 (no TP, se utiliza tween)
        print("Moviendo a la primera posición con tween...")
        local targetCF = CFrame.new(58, 52, 22)
        local distance = (targetCF.Position - rootPart.Position).Magnitude
        local tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        local tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
     
        
        -- Segunda posición (tween)
        print("Moviendo a segunda posición...")
        targetCF = CFrame.new(-23, 60, 15)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
      
        
        -- Tercera posición (tween)
        print("Moviendo a tercera posición...")
        targetCF = CFrame.new(-50, 82, 17)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
      
        
        -- Cuarta posición (tween)
        print("Moviendo a cuarta posición...")
        targetCF = CFrame.new(-95, 128, 18)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
  
        
        -- Quinta posición (tween)
        print("Moviendo a quinta posición...")
        targetCF = CFrame.new(-122, 131, 19)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
 
        
        -- Posición final (wave 3) (tween)
        print("Moviendo a posición final (wave 3)...")
        targetCF = CFrame.new(-241, 129, 9)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(
            distance / speed,
            Enum.EasingStyle.Linear
        )
        tween = TweenService:Create(rootPart, tweenInfo, {
            CFrame = targetCF
        })
        tween:Play()
        tween.Completed:Wait()
        
        isWaveTransitioning = false
        
        -- Continuar con la siguiente wave
        currentWave = currentWave + 1
        continue
    end
    
    if currentWave == 3 then
        print("Wave 3 completada, iniciando transición especial a Wave 4...")
        isWaveTransitioning = true
        cancelCurrentTween()
        
        local speed = 35  -- Velocidad base para los tweens, ahora establecida en 35
        task.wait(2)
        
        -- Primero, regresar a la posición principal de Wave 3 (-241, 129, 9)
        print("Regresando a la posición principal de Wave 3 (-241, 129, 9)...")
        local targetCF = CFrame.new(-241, 129, 9)
        local distance = (targetCF.Position - rootPart.Position).Magnitude
        local tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        task.wait(1)
        
        -- Luego, moverse a la posición intermedia (-300, 125, 48)
        print("Moviéndose a la posición intermedia (-300, 125, 48)...")
        targetCF = CFrame.new(-300, 125, 48)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        
   
        -- Por último, moverse a la posición final de Wave 4 (-367, 164, 47)
        print("Moviendo a Wave 4 (-367, 164, 47)...")
        targetCF = CFrame.new(-338, 151, 47)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        
        
        print("Moviendo a Wave 4 (-472, 244, 47)...")
        targetCF = CFrame.new(-364, 169, 46)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        
        
        print("Moviendo a Wave 4 (-475, 252, 47)...")
        targetCF = CFrame.new(-397, 188, 46)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        

        targetCF = CFrame.new(-468, 232, 47)
        distance = (targetCF.Position - rootPart.Position).Magnitude
        tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)
        tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCF })
        tween:Play()
        tween.Completed:Wait()
        
        
        rootPart.CFrame = targetCF
        isWaveTransitioning = false
        task.wait(1)
        
        currentWave = currentWave + 1  -- Se actualiza currentWave a 4
        continue
    end
    
    -- Preparar siguiente wave
    currentWave = currentWave + 1
    if currentWave <= 4 then
        print("Moviendo a Wave " .. currentWave)
        isWaveTransitioning = true
        
        local nextPos = wavePositions[currentWave]
        local moveSuccess = moveToNextWave(nextPos)
        
        if not moveSuccess then
            print("No se pudo mover a la siguiente wave")
            break
        end
        
        -- Agregar espera específica después del tween para Wave 2
        if currentWave == 2 then
            print("Posición de Wave 2 alcanzada - Esperando 5 segundos...")
            task.wait(6.5)  -- Espera de 5 segundos después de llegar a la posición
        end
        
        isWaveTransitioning = false
        task.wait(1)
    end
end
print("¡Waves 1-4 completadas!")

task.wait(4)  -- Espera 10 segundos

print("Wave 4 completada, esperando TP a Wave 5...")
task.wait(5)  -- Esperar 5 segundos después de Wave 4

-- Esperar hasta que el jugador sea teletransportado a la posición de Wave 5
local wave5TPPosition = Vector3.new(-1286, 140, 194)
local isTPed = false

while not isTPed do
    local distance = (rootPart.Position - wave5TPPosition).Magnitude
    if distance <= 100 then
        print("TP detectado a Wave 5, iniciando secuencia de ataque")
        isTPed = true
    end
    task.wait(0.1)
end

-- Waves 5-6 (similar a waves 1-4)
while currentWave >= 5 and currentWave <= 6 do
    print("Iniciando Wave " .. currentWave)
    
    -- Esperar NPCs (Leo o Cupid)
    repeat
        task.wait(0.1)
    until #workspace.NPCs:GetChildren() > 0
    
    -- Guardar posición inicial del boss
    if currentWave == 7 then
        local leo = workspace.NPCs:GetChildren()[1]
        if leo and leo:FindFirstChild("HumanoidRootPart") then
            leoInitialCFrame = leo.HumanoidRootPart.CFrame
            print("CFrame inicial de Leo guardado")
        end
    elseif currentWave == 8 then
        local cupid = workspace.NPCs:GetChildren()[1]
        if cupid and cupid:FindFirstChild("HumanoidRootPart") then
            cupidInitialCFrame = cupid.HumanoidRootPart.CFrame
            print("CFrame inicial de Cupid Queen guardado")
        end
    end
    
    local safeHeight = 200
    
    while areNPCsAlive() do
        local health = getCurrentHealth()
        
        -- Manejo de vida baja para Leo y Cupid
        if health < 300 then
            print("¡Vida baja! Retrocediendo...")
            
            if currentWave == 7 and leoInitialCFrame then
                -- Retroceso específico para Leo
                local safeCFrame = leoInitialCFrame * CFrame.new(0, safeHeight, 20)
                local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(rootPart, tweenInfo, { CFrame = safeCFrame })
                tween:Play()
                tween.Completed:Wait()
            elseif currentWave == 8 and cupidInitialCFrame then
                -- Retroceso específico para Cupid (aumenta altura progresivamente)
                safeHeight = safeHeight + 50
                local safeCFrame = cupidInitialCFrame * CFrame.new(0, safeHeight, 20)
                local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(rootPart, tweenInfo, { CFrame = safeCFrame })
                tween:Play()
                tween.Completed:Wait()
            end
            
            -- Esperar recuperación
            repeat
                task.wait(0.1)
                health = getCurrentHealth()
            until health >= 500
            print("Vida recuperada, volviendo al combate")
        else
            -- Procesar NPCs normalmente si la vida está bien
            processNPCs()
        end
        
        task.wait(0.1)
    end
    
    -- Manejo de finalización de wave
    if not areNPCsAlive() then
        print("Wave " .. currentWave .. " completada")
        currentWave = currentWave + 1
        
        -- Espera especial entre Leo y Cupid Queen
        if currentWave == 8 then
            print("Esperando aparición de Cupid Queen...")
            task.wait(3)
        end
    end
end

-- Waves 7-8 (Leo y Cupid)
while currentWave >= 7 and currentWave <= 8 do
    print("Iniciando Wave " .. currentWave .. " (Boss Fight)")
    
    -- Esperar NPCs (Leo o Cupid)
    repeat
        task.wait(0.1)
    until #workspace.NPCs:GetChildren() > 0
    
    -- Guardar posición inicial del boss
    if currentWave == 7 then
        local leo = workspace.NPCs:GetChildren()[1]
        if leo and leo:FindFirstChild("HumanoidRootPart") then
            leoInitialCFrame = leo.HumanoidRootPart.CFrame
            print("CFrame inicial de Leo guardado")
        end
    elseif currentWave == 8 then
        local cupid = workspace.NPCs:GetChildren()[1]
        if cupid and cupid:FindFirstChild("HumanoidRootPart") then
            cupidInitialCFrame = cupid.HumanoidRootPart.CFrame
            print("CFrame inicial de Cupid Queen guardado")
        end
    end
    
    while areNPCsAlive() do
        local health = getCurrentHealth()
        local boss = workspace.NPCs:GetChildren()[1]
        
        -- Manejo de vida baja para Leo y Cupid
        if health < 300 then
            print("¡Vida baja! Iniciando secuencia de recuperación... Vida actual:", health)
            
            -- Primero tween a la posición inicial de waves 5-6-7
            local safePos = Vector3.new(-1286, 140, 194)
            local distance = (safePos - rootPart.Position).Magnitude
            local tweenInfo = TweenInfo.new(
                distance / 100,  -- velocidad de 100 studs por segundo
                Enum.EasingStyle.Linear
            )
            
            local tween = TweenService:Create(rootPart, tweenInfo, {
                CFrame = CFrame.new(safePos)
            })
            
            print("Retrocediendo a posición segura general")
            tween:Play()
            tween.Completed:Wait()
            task.wait(0.5)
            
            -- Verificar si el boss está cerca y la vida aún no se recupera lo suficiente
            while health < 600 and boss and boss:FindFirstChild("HumanoidRootPart") do
                local bossDistance = (boss.HumanoidRootPart.Position - rootPart.Position).Magnitude
                health = getCurrentHealth()  -- Actualizar la vida en cada iteración
                print("Esperando recuperación... Vida actual:", health)
                
                if bossDistance < 100 then  -- Si el boss está demasiado cerca
                    print("Boss demasiado cerca, retrocediendo a su posición inicial")
                    
                    -- Tween a la posición inicial del boss correspondiente
                    local targetCFrame
                    if currentWave == 7 and leoInitialCFrame then
                        targetCFrame = leoInitialCFrame
                    elseif currentWave == 8 and cupidInitialCFrame then
                        targetCFrame = cupidInitialCFrame
                    end
                    
                    if targetCFrame then
                        distance = (targetCFrame.Position - rootPart.Position).Magnitude
                        tweenInfo = TweenInfo.new(
                            distance / 100,
                            Enum.EasingStyle.Linear
                        )
                        
                        tween = TweenService:Create(rootPart, tweenInfo, {
                            CFrame = targetCFrame
                        })
                        
                        tween:Play()
                        tween.Completed:Wait()
                    end
                end
                
                task.wait(0.1)
            end
            
            print("Vida recuperada a nivel seguro:", health, ". Volviendo al combate")
        else
            -- Procesar NPCs normalmente si la vida está bien
            processNPCs()
        end
        
        task.wait(0.1)
    end
    
    -- Manejo de finalización de wave
    if not areNPCsAlive() then
        print("Wave " .. currentWave .. " completada")
        currentWave = currentWave + 1
        
        -- Espera especial entre Leo y Cupid Queen
        if currentWave == 8 then
            print("Esperando aparición de Cupid Queen...")
            task.wait(3)
        end
    end
end

-- Sistema de recuperación para Leo (Wave 7)
while currentWave == 7 do  -- Wave de Leo
    local health = getCurrentHealth()
    local leo = workspace.NPCs:GetChildren()[1]
    
    if health and health < 200 then  -- Si la vida es menor a 200
        print("Vida baja detectada:", health, "- Iniciando modo recuperación")
        
        -- Cancelar cualquier proceso actual
        isWaveTransitioning = true
        isChasingNPC = false
        magmaSwampInProgress = false
        cancelCurrentTween()
        
        -- Si tenemos la posición de Leo
        if leo and leo:FindFirstChild("HumanoidRootPart") then
            local leoPos = leo.HumanoidRootPart.Position
            local safePos = Vector3.new(leoPos.X, leoPos.Y + 60, leoPos.Z)
            
            -- Moverse a la posición segura
            rootPart.CFrame = CFrame.new(safePos)
            
            -- Esperar hasta recuperar 600 de vida
            print("Esperando recuperación de vida...")
            repeat
                health = getCurrentHealth()
                task.wait(0.1)
                
                -- Mantener la posición sobre Leo
                if leo and leo:FindFirstChild("HumanoidRootPart") then
                    local currentLeoPos = leo.HumanoidRootPart.Position
                    rootPart.CFrame = CFrame.new(Vector3.new(currentLeoPos.X, currentLeoPos.Y + 60, currentLeoPos.Z))
                end
            until health >= 600 or not leo or not leo.Parent
            
            print("Vida recuperada:", health, "- Volviendo al combate")
        end
        
        isWaveTransitioning = false
    else
        -- Continuar con el proceso normal de ataque
        processNPCs()
    end
    
    task.wait(0.1)
    
    -- Verificar si Leo sigue vivo
    if not areNPCsAlive() then
        print("Leo derrotado - Wave 7 completada")
        break
    end
end

while currentWave == 8 do  -- Wave de Cupid Queen
    local health = getCurrentHealth()
    local cupid = workspace.NPCs:GetChildren()[1]
    
    if health and health < 200 then  -- Si la vida es menor a 200
        print("Vida baja detectada:", health, "- Iniciando modo recuperación")
        
        -- Cancelar cualquier proceso actual
        isWaveTransitioning = true
        isChasingNPC = false
        magmaSwampInProgress = false
        cancelCurrentTween()
        
        -- Si tenemos la posición de Cupid Queen
        if cupid and cupid:FindFirstChild("HumanoidRootPart") then
            local cupidPos = cupid.HumanoidRootPart.Position
            local safePos = Vector3.new(cupidPos.X, cupidPos.Y + 60, cupidPos.Z)
            
            -- Moverse a la posición segura
            rootPart.CFrame = CFrame.new(safePos)
            
            -- Esperar hasta recuperar 600 de vida
            print("Esperando recuperación de vida...")
            repeat
                health = getCurrentHealth()
                task.wait(0.1)
                
                -- Mantener la posición sobre Cupid Queen
                if cupid and cupid:FindFirstChild("HumanoidRootPart") then
                    local currentCupidPos = cupid.HumanoidRootPart.Position
                    rootPart.CFrame = CFrame.new(Vector3.new(currentCupidPos.X, currentCupidPos.Y + 60, currentCupidPos.Z))
                end
            until health >= 600 or not cupid or not cupid.Parent
            
            print("Vida recuperada:", health, "- Volviendo al combate")
        end
        
        isWaveTransitioning = false
    else
        -- Continuar con el proceso normal de ataque
        processNPCs()
    end
    
    task.wait(0.1)
    
    -- Verificar si Cupid Queen sigue viva
    if not areNPCsAlive() then
        print("Cupid Queen derrotada - Wave 8 completada")
        break
    end
end
